MODEL:
  TYPE: 'seg'
  NAME: 'CascadeEncoderDecoder'
  PRETRAINED_MODEL_PATH: ""
  NUM_STAGES: 2
  BACKBONE:
    type: 'HRNet'
    norm_cfg: {
      type: 'BN', 
      requires_grad: True}
    norm_eval: False
    extra: {
      stage1: {
        num_modules: 1,
        num_branches: 1,
        block: 'BOTTLENECK',
        num_blocks: [4],
        num_channels: [64]},
      stage2: {
        num_modules: 1,
        num_branches: 2,
        block: 'BASIC',
        num_blocks: [4, 4],
        num_channels: [18, 36]},
      stage3: {
        num_modules: 4,
        num_branches: 3,
        block: 'BASIC',
        num_blocks: [4, 4, 4],
        num_channels: [18, 36, 72]},
      stage4: {
        num_modules: 3,
        num_branches: 4,
        block: 'BASIC',
        num_blocks: [4, 4, 4, 4],
        num_channels: [18, 36, 72, 144]}}
  DECODE_HEAD:
    head_1: { 
      type: 'SegFCNHead',
      in_channels: [18, 36, 72, 144],
      in_index: [0, 1, 2, 3],
      channels: 270,
      input_transform: 'resize_concat',
      kernel_size: 1,
      num_convs: 1,
      concat_input: False,
      dropout_ratio: -1,
      num_classes: 5,
      norm_cfg: {
        type: 'BN', 
        requires_grad: True},
      align_corners: False}
    head_2: {
      type: 'OCRHead',
      in_channels: [18, 36, 72, 144],
      in_index: [0, 1, 2, 3],
      input_transform: 'resize_concat',
      channels: 512,
      ocr_channels: 256,
      dropout_ratio: -1,
      num_classes: 5,
      norm_cfg: {
        type: 'BN', 
        requires_grad: True},
      align_corners: False}
  LOSS:
    loss_1: {
      type: 'CrossEntropyLoss', 
      use_sigmoid: False, 
      loss_weight: 0.4,
    }
    loss_2: {
      type: 'CrossEntropyLoss', 
      use_sigmoid: False, 
      loss_weight: 1.0,
    }
  TEST_CFG:
    mode: 'whole'
